dim mat1
mat1 <- matrix(1:25, 5,5)
dim mat1
dim(mat1)
art1 <- array( 1:75, c(5, 5, 3))
art1
art1[,,1]
art1[,,1]
art[2,1,1]
art1[2,1,1]
MyList <- list(species=c("Quercus robur","Fraxinus excelsior"), age=c(123, 84))
MyList
MyList[1]
MyList[1]
MyList[[1]]
TreeData <- read.csv("../data/trees.csv")
head(TreeData)
len(TreeData$Distance.m)
length(TreeData$Distance.m)
TreeData$Distance.m[2]
# A simple script to illustrate R input-output.  
# Run line by line and check inputs outputs to understand what is happening  
MyData <- read.csv("../data/trees.csv", header = TRUE) # import with headers
write.csv(MyData, "../results/MyData.csv") #write it out as a new file
write.table(MyData[1,], file = "../results/MyData.csv",append=TRUE) # Append to it
write.csv(MyData, "../results/MyData.csv", row.names=TRUE) # write row names
write.table(MyData, "../results/MyData.csv", col.names=FALSE) # ignore column names
MyData <- read.csv("../data/trees.csv", header = TRUE)
write.csv(MyData, "../results/MyData.csv")
MyData <- read.csv("../data/trees.csv", header = TRUE)
write.csv(MyData, "../results/MyData.csv")
write.table(MyData[1,], file = "../results/MyData.csv",append=TRUE)
write.csv(MyData, "../results/MyData.csv", row.names=TRUE)
write.table(MyData, "../results/MyData.csv", col.names=FALSE)
# Load required libraries
library(dplyr)
# Load the 'trees.csv' data
data <- read.csv("trees.csv")
# Calculate tree heights
data <- data %>%
  mutate(Tree.Height.m = TreeHeight(Angle.degrees, Distance.m))
# Save the results to 'TreeHts.csv' in the 'results' directory
write.csv(data, file = "results/TreeHts.csv", row.names = FALSE)
# Display the first few rows of the result
head(data)
# Load required libraries
library(dplyr)
# Load the 'trees.csv' data
data <- read.csv("../data/trees.csv")
# Calculate tree heights
data <- data %>%
  mutate(Tree.Height.m = TreeHeight(Angle.degrees, Distance.m))
# Save the results to 'TreeHts.csv' in the 'results' directory
write.csv(data, file = "results/TreeHts.csv", row.names = FALSE)
# Display the first few rows of the result
head(data)
TreeHeight <- function(degrees, distance) {
    radians <- degrees * pi / 180
    height <- distance * tan(radians)
    print(paste("Tree height is:", height))
  
    return (height)
}
# Load required libraries
library(dplyr)
# Load the 'trees.csv' data
data <- read.csv("../data/trees.csv")
# Calculate tree heights
data <- data %>%
  mutate(Tree.Height.m = TreeHeight(Angle.degrees, Distance.m))
# Save the results to 'TreeHts.csv' in the 'results' directory
write.csv(data, file = "results/TreeHts.csv", row.names = FALSE)
# Display the first few rows of the result
head(data)
# Load required libraries
library(dplyr)
# Load the 'trees.csv' data
data <- read.csv("../data/trees.csv")
# Calculate tree heights
data <- data %>%
  mutate(Tree.Height.m = TreeHeight(Angle.degrees, Distance.m))
# Save the results to 'TreeHts.csv' in the 'results' directory
write.csv(data, file = "../results/TreeHts.csv", row.names = FALSE)
# Display the first few rows of the result
head(data)
rm(list=ls())
setwd("/week4/code")
d<-read.table("../data/ho2_sparrowsize.txt",header=TRUE)
table(d$Year,d$BirdID)
rm(list = ls())

stochrickvect <- function(p0 = runif(1000, 0.5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears = 100)
{

  N <- matrix(NA, numyears, length(p0))  #initialize empty matrix

  N[1, ] <- p0
# Generate random fluctuations for all years at once
  fluctuations <- matrix(rnorm(numyears * length(p0), mean = 0, sd = sigma), nrow = numyears)
    for (yr in 2:numyears){ #for each pop, loop through the years

      N[yr, ] <- N[yr-1, ] * exp(r * (1 - N[yr - 1, ] / K) + fluctuations[yr, ]) # add one fluctuation from normal distribution
    
     }
  
 return(N)

}

print("Vectorized Stochastic Ricker takes:")
print(system.time(res2<-stochrickvect()))
rm(list = ls())

stochrick <- function(p0 = runif(1000, 0.5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears = 100)
{

  N <- matrix(NA, numyears, length(p0))  #initialize empty matrix

  N[1, ] <- p0

  for (pop in 1:length(p0)) { #loop through the populations

    for (yr in 2:numyears){ #for each pop, loop through the years

      N[yr, pop] <- N[yr-1, pop] * exp(r * (1 - N[yr - 1, pop] / K) + rnorm(1, 0, sigma)) # add one fluctuation from normal distribution
    
     }
  
  }
 return(N)

}
system.time(stochrick())
rm(list=ls())

load("../data/KeyWestAnnualMeanTemperature.RData")

ls()

class(ats)

head(ats)

plot(ats)

# Calculate the observed correlation coefficient
observed_cor <- cor(ats$Year, ats$Temp)

# Set the number of permutations
n_permutations <- 10000  # You can increase this for more accuracy

# Initialize a vector to store permutation correlation coefficients
perm_cor <- numeric(n_permutations)

# Perform the permutation test
for (i in 1:n_permutations) {
  # Shuffle the temperature data while keeping the years in the same order
  shuffled_temp <- sample(ats$Temp)
  
  # Calculate the correlation coefficient for the shuffled data
  perm_cor[i] <- cor(ats$Year, shuffled_temp)
}

perm_cor
observed_cor
p_value <- length(observed_cor>= perm_cor) / n_permutations
p_value
length(observed_cor>= perm_cor)
shuffled_temp
rm(list=ls())

load("../data/KeyWestAnnualMeanTemperature.RData")

ls()

class(ats)

head(ats)

plot(ats)

# Calculate the observed correlation coefficient
observed_cor <- cor(ats$Year, ats$Temp)

# Set the number of permutations
n_permutations <- 1000000  # You can increase this for more accuracy

# Initialize a vector to store permutation correlation coefficients
perm_cor <- numeric(n_permutations)

# Perform the permutation test
for (i in 1:n_permutations) {
  # Shuffle the temperature data while keeping the years in the same order
  shuffled_temp <- sample(ats$Temp)
  
  # Calculate the correlation coefficient for the shuffled data
  perm_cor[i] <- cor(ats$Year, shuffled_temp)
}

perm_cor
observed_cor
p_value <- length(observed_cor>= perm_cor) / n_permutations

p_value
rm(list=ls())

load("../data/KeyWestAnnualMeanTemperature.RData")

ls()

class(ats)

head(ats)

plot(ats)

# Calculate the observed correlation coefficient
observed_cor <- cor(ats$Year, ats$Temp)

# Set the number of permutations
n_permutations <- 1000000  # You can increase this for more accuracy

# Initialize a vector to store permutation correlation coefficients
perm_cor <- numeric(n_permutations)

# Perform the permutation test
for (i in 1:n_permutations) {
  # Shuffle the temperature data while keeping the years in the same order
  shuffled_temp <- sample(ats$Temp)
  
  # Calculate the correlation coefficient for the shuffled data
  perm_cor[i] <- cor(ats$Year, shuffled_temp)
}

perm_cor
observed_cor
p_value <- length(perm_cor >= observed_cor) / n_permutations

p_value
rm(list=ls())

load("../data/KeyWestAnnualMeanTemperature.RData")

ls()

class(ats)

head(ats)

plot(ats)

# Calculate the observed correlation coefficient
observed_cor <- cor(ats$Year, ats$Temp)

# Set the number of permutations
n_permutations <- 10000  # You can increase this for more accuracy

# Initialize a vector to store permutation correlation coefficients
perm_cor <- numeric(n_permutations)

# Perform the permutation test
for (i in 1:n_permutations) {
  # Shuffle the temperature data while keeping the years in the same order
  shuffled_temp <- sample(ats$Temp)
  
  # Calculate the correlation coefficient for the shuffled data
  perm_cor[i] <- cor(ats$Year, shuffled_temp)
}

perm_cor
observed_cor
p_value <- length(perm_cor >= observed_cor) / n_permutations

p_value
rm(list=ls())

load("../data/KeyWestAnnualMeanTemperature.RData")

ls()

class(ats)

head(ats)

plot(ats)

# Calculate the observed correlation coefficient
observed_cor <- cor(ats$Year, ats$Temp)

# Set the number of permutations
n_permutations <- 10000  # You can increase this for more accuracy

# Initialize a vector to store permutation correlation coefficients
perm_cor <- numeric(n_permutations)

# Perform the permutation test
for (i in 1:n_permutations) {
  # Shuffle the temperature data while keeping the years in the same order
  shuffled_temp <- sample(ats$Temp)
  
  # Calculate the correlation coefficient for the shuffled data
  perm_cor[i] <- cor(ats$Year, shuffled_temp)
}

perm_cor
observed_cor
p_value <- length(observed_cor >= perm_cor) / n_permutations

p_value
install.packages('terra')
?melt
require(reshape2)
?melt
# Load necessary libraries
library(ggplot2)
library(dplyr)

# Set working directory
data_dir <- "Data/"  # Directory containing the dataset
output_dir <- "Output/"  # Directory to save plots and results
setwd("Path_to_your_working_directory")  # Set your working directory here

# Read the predator-prey dataset
pred_prey_data <- read.csv(paste0(data_dir, "Predator_Prey_Data.csv"))

# Linear regression and plot
regression_results <- pred_prey_data %>%
  group_by(Feeding_Type, Predator_Life_Stage) %>%
  do(model = lm(log(prey_mass) ~ log(predator_mass), data = .)) %>%
  do(data.frame(
    Feeding_Type = .$Feeding_Type,
    Predator_Life_Stage = .$Predator_Life_Stage,
    slope = coef(.$model)[2],
    intercept = coef(.$model)[1],
    R = summary(.$model)$r.squared,
    F_statistic = summary(.$model)$fstatistic[1],
    p_value = summary(.$model)$fstatistic[4]
  ))

# Save regression results to a CSV file
write.csv(regression_results, file = paste0(output_dir, "PP_Regress_Results.csv"), row.names = FALSE)

# Create a plot with regression lines
pdf(paste0(output_dir, "Regression_Plot.pdf"))
ggplot(pred_prey_data, aes(x = log(predator_mass), y = log(prey_mass))) +
  geom_point() +
  geom_smooth(aes(color = Feeding_Type, linetype = Predator_Life_Stage), method = "lm", se = FALSE) +
  labs(title = "Linear Regression of Prey Mass on Predator Mass by Feeding Type and Predator Life Stage")
dev.off()

MyDF <- read.csv("../data/EcolArchives-E089-51-D1.csv")
dim(MyDF) #check the size of the data frame you loaded
MyDF$MyData <- read.csv("../data/trees.csv", header = TRUE) # import with headers

write.csv(MyData, "../results/MyData.csv") #write it out as a new file

write.table(MyData[1,], file = "../results/MyData.csv",append=TRUE) # Append to it

write.csv(MyData, "../results/MyData.csv", row.names=TRUE) # write row names

write.table(MyData, "../results/MyData.csv", col.names=FALSE) # ignore column names
getwd()
source(control_flow.R)
source("control_flow.R")
source("preallocate.R")
source("preallocate.R")
source("preallocate.R")
M <- matrix(rnorm(100), 10, 10)
RowMeans <- apply(M, 1, mean)
print(RowMeans)

ColMeans <- apply(M, 2, mean)

## Now the variance
RowVars <- apply(M, 1, var)
print (RowVars)

## By column
ColMeans <- apply(M, 2, mean)
print (ColMeans)
source("try.R")
source("Girko.R")
source("TreeHeight_edit.R")
# Runs the stochastic Ricker equation with gaussian fluctuations

rm(list = ls())

stochrick <- function(p0 = runif(1000, 0.5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears = 100)
{

  N <- matrix(NA, numyears, length(p0))  #initialize empty matrix

  N[1, ] <- p0

  for (pop in 1:length(p0)) { #loop through the populations

    for (yr in 2:numyears){ #for each pop, loop through the years

      N[yr, pop] <- N[yr-1, pop] * exp(r * (1 - N[yr - 1, pop] / K) + rnorm(1, 0, sigma)) # add one fluctuation from normal distribution
    
     }
  
  }
 return(N)

}
system.time(stochrick())

# Now write another function called stochrickvect that vectorizes the above to
# the extent possible, with improved performance: 

# print("Vectorized Stochastic Ricker takes:")
# print(system.time(res2<-stochrickvect()))

rm(list = ls())

stochrickvect <- function(p0 = runif(1000, 0.5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears = 100)
{

  N <- matrix(NA, numyears, length(p0))  #initialize empty matrix

  N[1, ] <- p0
# Generate random fluctuations for all years at once
  fluctuations <- matrix(rnorm(numyears * length(p0), mean = 0, sd = sigma), nrow = numyears)
    for (yr in 2:numyears){ #for each pop, loop through the years

      N[yr, ] <- N[yr-1, ] * exp(r * (1 - N[yr - 1, ] / K) + fluctuations[yr, ]) 
      # add one fluctuation from normal distribution
    
     }
  
 return(N)

}

print("Vectorized Stochastic Ricker takes:")
print(system.time(res2<-stochrickvect()))
rm(list=ls())

load("../data/KeyWestAnnualMeanTemperature.RData")

ls()

class(ats)

head(ats)

plot(ats)

# Calculate the observed correlation coefficient
observed_cor <- cor(ats$Year, ats$Temp)

# Set the number of permutations
n_permutations <- 10000  # You can increase this for more accuracy

# Initialize a vector to store permutation correlation coefficients
perm_cor <- numeric(n_permutations)

# Perform the permutation test
for (i in 1:n_permutations) {
  # Shuffle the temperature data while keeping the years in the same order
  shuffled_temp <- sample(ats$Temp)
  
  # Calculate the correlation coefficient for the shuffled data
  perm_cor[i] <- cor(ats$Year, shuffled_temp)
}

perm_cor
observed_cor
p_value <- sum(perm_cor >= observed_cor) / n_permutations

p_value
rm(list=ls())

load("../data/KeyWestAnnualMeanTemperature.RData")

ls()

class(ats)

head(ats)

plot(ats)

# Calculate the observed correlation coefficient
observed_cor <- cor(ats$Year, ats$Temp)

# Set the number of permutations
n_permutations <- 10000  # You can increase this for more accuracy

# Initialize a vector to store permutation correlation coefficients
perm_cor <- numeric(n_permutations)

# Perform the permutation test
for (i in 1:n_permutations) {
  # Shuffle the temperature data while keeping the years in the same order
  shuffled_temp <- sample(ats$Temp)
  
  # Calculate the correlation coefficient for the shuffled data
  perm_cor[i] <- cor(ats$Year, shuffled_temp)
}

observed_cor
p_value <- sum(perm_cor >= observed_cor) / n_permutations

p_value
source("PP_Dists.R")
source("PP_Dists.R")
source("PP_Dists.R")
source("PP_Dists.R")
source("PP_Dists.R")
source("PP_Dists.R")
source("PP_Dists.R")
source("PP_Regress.R")
source("PP_Regress.R")
source("PP_Regress.R")
source("PP_Regress.R")
source("PP_Regress.R")
source("PP_Regress.R")
source("PP_Regress.R")
source("PP_Regress.R")
source("PP_Regress.R")
source("notes.R")
source("notes.R")
source("notes.R")
source("notes.R")
install.packages("maps")
load("../data/GPDDFiltered.RData")
source("PP_regress.R")
source("PP_regress.R")
fit
library(tidyverse)

# Set the path to the dataset and read it
data_path <- "../data/EcolArchives-E089-51-D1.csv"
df <- read_csv(data_path)

# Add a new variable for log predator and prey mass
df <- df %>%
  mutate(log_predator_mass = log(Predator.mass),
         log_prey_mass = log(Prey.mass))

# Initialize a list to store regression results
regress_results <- list()

# Function to perform regression and plot
perform_regression <- function(data, feeding_type, life_stage) {
  # Filter the data for the given feeding type and life stage
  filtered_data <- data %>%
    filter(Type.of.feeding.interaction == feeding_type,
           Predator.lifestage == life_stage)
  
  # Perform linear regression
  fit <- lm(log_prey_mass ~ log_predator_mass, data = filtered_data)
  
  # Store the summary statistics
  regress_results[[paste(feeding_type, life_stage, sep = "_")]] <- summary(fit)
fit
library(tidyverse)

# Set the path to the dataset and read it
data_path <- "../data/EcolArchives-E089-51-D1.csv"
df <- read_csv(data_path)

# Add a new variable for log predator and prey mass
df <- df %>%
  mutate(log_predator_mass = log(Predator.mass),
         log_prey_mass = log(Prey.mass))

# Initialize a list to store regression results
regress_results <- list()

# Function to perform regression and plot
perform_regression <- function(data, feeding_type, life_stage) {
  # Filter the data for the given feeding type and life stage
  filtered_data <- data %>%
    filter(Type.of.feeding.interaction == feeding_type,
           Predator.lifestage == life_stage)
  
  # Perform linear regression
  fit <- lm(log_prey_mass ~ log_predator_mass, data = filtered_data)
  
  # Store the summary statistics
  regress_results[[paste(feeding_type, life_stage, sep = "_")]] <- summary(fit)
  
  # Plot
  p <- ggplot(filtered_data, aes(x = log_predator_mass, y = log_prey_mass)) +
    geom_point() +
    geom_smooth(method = "lm", se = FALSE, color = "blue") +
    labs(title = paste("Regression of Log Prey Mass on Log Predator Mass\n",
                       "Feeding Type:", feeding_type, "- Life Stage:", life_stage),
         x = "Log Predator Mass (g)", y = "Log Prey Mass (g)")
  
  return(p)
}
source("PP_regress.R")
source("PP_regress.R")
source("PP_regress.R")
source("PP_regress.R")
source("PP_regress.R")
  fit <- lm(log_prey_mass ~ log_predator_mass, data = filtered_data)
  filtered_data <- data %>%
    filter(Type.of.feeding.interaction == feeding_type,
           Predator.lifestage == life_stage)
  
  # Perform linear regression
  fit <- lm(log_prey_mass ~ log_predator_mass, data = filtered_data)
  filtered_data <- data %>%
    filter(Type.of.feeding.interaction == feeding_type,
           Predator.lifestage == life_stage)
  
  # Perform linear regression
  fit <- lm(log_prey_mass ~ log_predator_mass, data = filtered_data)
  filtered_data <- data %>%
    filter(Type.of.feeding.interaction == feeding_type,
           Predator.lifestage == life_stage)
  
  # Perform linear regression
  fit <- lm(log_prey_mass ~ log_predator_mass, data = filtered_data)
source("PP_regress.R")
source("PP_regress.R")
source("PP_regress.R")
source("PP_regress.R")
source("PP_regress.R")
source("PP_regress.R")
library(tidyverse)

# Set the path to the dataset and read it
df <- read.csv("../data/EcolArchives-E089-51-D1.csv", header = TRUE, sep = ",", stringsAsFactors = TRUE)

fit <- lm(df$log_prey_mass ~ df$log_predator_mass, data = filtered_data)

regression_results <- data %>%
  group_by(Type.of.feeding.interaction, Predator.lifestage) %>%
  do(model = lm(Prey.mass ~ Predator.mass, data = .)) %>%
  summarize(
    slope = coef(model)[[2]],
    intercept = coef(model)[[1]],
    R = summary(model)$r.squared,
    F_statistic = summary(model)$fstatistic[1],
    p_value = summary(model)$fstatistic[2]
  )

write.csv(regression_results, "../results/PP_Regress_Results.csv", row.names = FALSE)
library(tidyverse)

# Set the path to the dataset and read it
df <- read.csv("../data/EcolArchives-E089-51-D1.csv", header = TRUE, sep = ",", stringsAsFactors = TRUE)

fit <- lm(df$log_prey_mass ~ df$log_predator_mass, data = filtered_data)

regression_results <- data %>%
  group_by(Type.of.feeding.interaction, Predator.lifestage) %>%
  do(model = lm(Prey.mass ~ Predator.mass, data = .)) %>%
  summarize(
    slope = coef(model)[[2]],
    intercept = coef(model)[[1]],
    R = summary(model)$r.squared,
    F_statistic = summary(model)$fstatistic[1],
    p_value = summary(model)$fstatistic[2]
  )

write.csv(regression_results, "../results/PP_Regress_Results.csv", row.names = FALSE)library(tidyverse)

# Set the path to the dataset and read it
df <- read.csv("../data/EcolArchives-E089-51-D1.csv", header = TRUE, sep = ",", stringsAsFactors = TRUE)

df <- df %>%
  mutate(log_predator_mass = log(Predator.mass),
         log_prey_mass = log(Prey.mass))
fit <- lm(df$log_prey_mass ~ df$log_predator_mass, data = filtered_data)

regression_results <- data %>%
  group_by(Type.of.feeding.interaction, Predator.lifestage) %>%
  do(model = lm(Prey.mass ~ Predator.mass, data = .)) %>%
  summarize(
    slope = coef(model)[[2]],
    intercept = coef(model)[[1]],
    R = summary(model)$r.squared,
    F_statistic = summary(model)$fstatistic[1],
    p_value = summary(model)$fstatistic[2]
  )

write.csv(regression_results, "../results/PP_Regress_Results.csv", row.names = FALSE)
library(tidyverse)

# Set the path to the dataset and read it
df <- read.csv("../data/EcolArchives-E089-51-D1.csv", header = TRUE, sep = ",", stringsAsFactors = TRUE)

regression_results <- data %>%
  group_by(Type.of.feeding.interaction, Predator.lifestage) %>%
  do(model = lm(Prey.mass ~ Predator.mass, data = .)) %>%
  summarize(
    slope = coef(model)[[2]],
    intercept = coef(model)[[1]],
    R = summary(model)$r.squared,
    F_statistic = summary(model)$fstatistic[1],
    p_value = summary(model)$fstatistic[2]
  )

write.csv(regression_results, "../results/PP_Regress_Results.csv", row.names = FALSE)
library(ggplot2)
library(dplyr)

# Set the path to the dataset and read it
df <- read.csv("../data/EcolArchives-E089-51-D1.csv", header = TRUE, sep = ",", stringsAsFactors = TRUE)

regression_results <- data %>%
  group_by(Type.of.feeding.interaction, Predator.lifestage) %>%
  do(model = lm(Prey.mass ~ Predator.mass, data = .)) %>%
  summarize(
    slope = coef(model)[[2]],
    intercept = coef(model)[[1]],
    R = summary(model)$r.squared,
    F_statistic = summary(model)$fstatistic[1],
    p_value = summary(model)$fstatistic[2]
  )

write.csv(regression_results, "../results/PP_Regress_Results.csv", row.names = FALSE)

pdf("../Results/PP_Regress_Plot.pdf") # Save plot as a PDF in the Results directory
ggplot(data, aes(x = Predator.mass, y = Prey.mass, color = Type.of.feeding.interaction)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  facet_grid(.~Predator.lifestage) +
  labs(title = "Linear Regression on Predator-Prey Interactions") +
  theme_minimal()
dev.off()
library(ggplot2)
library(dplyr)

# Set the path to the dataset and read it
df <- read.csv("../data/EcolArchives-E089-51-D1.csv", header = TRUE, sep = ",", stringsAsFactors = TRUE)

regression_results <- data %>%
  group_by(Type.of.feeding.interaction, Predator.lifestage) %>%
  do(model = lm(Prey.mass ~ Predator.mass, data = .)) %>%
  summarize(
    slope = coef(model)[[2]],
    intercept = coef(model)[[1]],
    R = summary(model)$r.squared,
    F_statistic = summary(model)$fstatistic[1],
    p_value = summary(model)$fstatistic[2]
  )

write.csv(regression_results, "../results/PP_Regress_Results.csv", row.names = FALSE)

pdf("../results/PP_Regress_Plot.pdf") # Save plot as a PDF in the Results directory
ggplot(data, aes(x = Predator.mass, y = Prey.mass, color = Type.of.feeding.interaction)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  facet_grid(.~Predator.lifestage) +
  labs(title = "Linear Regression on Predator-Prey Interactions") +
  theme_minimal()
dev.off()
library(ggplot2)
library(dplyr)

# Set the path to the dataset and read it
df <- read.csv("../data/EcolArchives-E089-51-D1.csv", header = TRUE, sep = ",", stringsAsFactors = TRUE)

regression_results <- data %>%
  group_by(Type.of.feeding.interaction, Predator.lifestage) %>%
  do(model = lm(Prey.mass ~ Predator.mass, data = .)) %>%
  summarize(
    slope = coef(model)[[2]],
    intercept = coef(model)[[1]],
    R = summary(model)$r.squared,
    F_statistic = summary(model)$fstatistic[1],
    p_value = summary(model)$fstatistic[2]
  )

write.csv(regression_results, "../results/PP_Regress_Results.csv", row.names = FALSE)

pdf("../results/PP_Regress_Plot.pdf") # Save plot as a PDF in the Results directory
par(mfrow=c(1,5))
ggplot(data, aes(x = Predator.mass, y = Prey.mass, color = Type.of.feeding.interaction)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  facet_grid(.~Predator.lifestage) +
  labs(title = "Linear Regression on Predator-Prey Interactions") +
  theme_minimal()
dev.off()
library(ggplot2)
library(dplyr)

# Set the path to the dataset and read it
df <- read.csv("../data/EcolArchives-E089-51-D1.csv", header = TRUE, sep = ",", stringsAsFactors = TRUE)

regression_results <- data %>%
  group_by(Type.of.feeding.interaction, Predator.lifestage) %>%
  do(model = lm(Prey.mass ~ Predator.mass, data = .)) %>%
  summarize(
    slope = coef(model)[[2]],
    intercept = coef(model)[[1]],
    R = summary(model)$r.squared,
    F_statistic = summary(model)$fstatistic[1],
    p_value = summary(model)$fstatistic[2]
  )

write.csv(regression_results, "../results/PP_Regress_Results.csv", row.names = FALSE)

pdf("../results/PP_Regress_Plot.pdf") # Save plot as a PDF in the Results directory
par(mfrow=c(5,1))
ggplot(data, aes(x = Predator.mass, y = Prey.mass, color = Type.of.feeding.interaction)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  facet_grid(.~Predator.lifestage) +
  labs(title = "Linear Regression on Predator-Prey Interactions") +
  theme_minimal()
dev.off()
source("PP_Regress.R")
source("PP_Regress.R")
source("PP_Regress.R")
source("PP_Regress.R")
source("PP_Regress.R")
source("PP_Regress.R")
rm(list=ls())

load("../data/KeyWestAnnualMeanTemperature.RData")

ls()

class(ats)

head(ats)

plot(ats)

# Calculate the observed correlation coefficient
observed_cor <- cor(ats$Year, ats$Temp)

# Set the number of permutations
n_permutations <- 10000  # You can increase this for more accuracy

# Initialize a vector to store permutation correlation coefficients
perm_cor <- numeric(n_permutations)

# Perform the permutation test
for (i in 1:n_permutations) {
  # Shuffle the temperature data while keeping the years in the same order
  shuffled_temp <- sample(ats$Temp)
  
  # Calculate the correlation coefficient for the shuffled data
  perm_cor[i] <- cor(ats$Year, shuffled_temp)
}
# Assuming you've already conducted the permutation test and have the perm_cor vector

# Load necessary libraries
library(ggplot2)

# Create a density plot of permutation correlation coefficients
density_plot <- ggplot(perm_cor, aes(x = perm_cor)) +
  geom_density(fill = "skyblue", color = "black") +
  labs(title = "Density Plot of Permutation Correlation Coefficients",
       x = "Correlation Coefficients",
       y = "Density")

# Display the plot
print(density_plot)


p_value <- sum(perm_cor >= observed_cor) / n_permutations

p_value

rm(list=ls())

load("../data/KeyWestAnnualMeanTemperature.RData")

ls()

class(ats)

head(ats)

plot(ats)

# Calculate the observed correlation coefficient
observed_cor <- cor(ats$Year, ats$Temp)

# Set the number of permutations
n_permutations <- 10000  # You can increase this for more accuracy

# Initialize a vector to store permutation correlation coefficients
perm_cor <- numeric(n_permutations)

# Perform the permutation test
for (i in 1:n_permutations) {
  # Shuffle the temperature data while keeping the years in the same order
  shuffled_temp <- sample(ats$Temp)
  
  # Calculate the correlation coefficient for the shuffled data
  perm_cor[i] <- cor(ats$Year, shuffled_temp)
}
# Assuming you've already conducted the permutation test and have the perm_cor vector

# Load necessary libraries
library(ggplot2)

# Create a density plot of permutation correlation coefficients
density_plot <- ggplot(data.frame(perm_cor = perm_cor), aes(x = perm_cor)) +
  geom_density(fill = "skyblue", color = "black") +
  labs(title = "Density Plot of Permutation Correlation Coefficients",
       x = "Correlation Coefficients",
       y = "Density")

# Display the plot
print(density_plot)


p_value <- sum(perm_cor >= observed_cor) / n_permutations

p_value

print(density_plot)
rm(list=ls())

load("../data/KeyWestAnnualMeanTemperature.RData")
# Calculate the observed correlation coefficient
observed_cor <- cor(ats$Year, ats$Temp)

# Set the number of permutations
n_permutations <- 10000  # You can increase this for more accuracy

# Initialize a vector to store permutation correlation coefficients
perm_cor <- numeric(n_permutations)

# Perform the permutation test
for (i in 1:n_permutations) {
  # Shuffle the temperature data while keeping the years in the same order
  shuffled_temp <- sample(ats$Temp)
  
  # Calculate the correlation coefficient for the shuffled data
  perm_cor[i] <- cor(ats$Year, shuffled_temp)
}
# Assuming you've already conducted the permutation test and have the perm_cor vector

# Load necessary libraries
library(ggplot2)

# Create a density plot of permutation correlation coefficients
density_plot <- ggplot(data.frame(perm_cor = perm_cor), aes(x = perm_cor)) +
  geom_density(fill = "skyblue", color = "black") +
  labs(title = "Density Plot of Permutation Correlation Coefficients",
       x = "Correlation Coefficients",
       y = "Density")

# Display the plot
print(density_plot)


p_value <- sum(perm_cor >= observed_cor) / n_permutations

p_value
rm(list=ls())

load("../data/KeyWestAnnualMeanTemperature.RData")
# Calculate the observed correlation coefficient
observed_cor <- cor(ats$Year, ats$Temp)

# Set the number of permutations
n_permutations <- 10000  # You can increase this for more accuracy

# Initialize a vector to store permutation correlation coefficients
perm_cor <- numeric(n_permutations)

# Perform the permutation test
for (i in 1:n_permutations) {
  # Shuffle the temperature data while keeping the years in the same order
  shuffled_temp <- sample(ats$Temp)
  
  # Calculate the correlation coefficient for the shuffled data
  perm_cor[i] <- cor(ats$Year, shuffled_temp)
}
# Assuming you've already conducted the permutation test and have the perm_cor vector

# Load necessary libraries
library(ggplot2)

# Create a density plot of permutation correlation coefficients
ggplot(data.frame(perm_cor = perm_cor), aes(x = perm_cor)) +
  geom_density(fill = "skyblue", color = "black") +
  labs(title = "Density Plot of Permutation Correlation Coefficients",
       x = "Correlation Coefficients",
       y = "Density")
ggsave("../results/Florida.pdf", device = "pdf")


p_value <- sum(perm_cor >= observed_cor) / n_permutations

p_value

rm(list=ls())

load("../data/KeyWestAnnualMeanTemperature.RData")
# Calculate the observed correlation coefficient
observed_cor <- cor(ats$Year, ats$Temp)

# Set the number of permutations
n_permutations <- 10000  # You can increase this for more accuracy

# Initialize a vector to store permutation correlation coefficients
perm_cor <- numeric(n_permutations)

# Perform the permutation test
for (i in 1:n_permutations) {
  # Shuffle the temperature data while keeping the years in the same order
  shuffled_temp <- sample(ats$Temp)
  
  # Calculate the correlation coefficient for the shuffled data
  perm_cor[i] <- cor(ats$Year, shuffled_temp)
}
# Assuming you've already conducted the permutation test and have the perm_cor vector

# Load necessary libraries
library(ggplot2)

# Create a density plot of permutation correlation coefficients
ggplot(data.frame(perm_cor = perm_cor), aes(x = perm_cor)) +
  geom_density(fill = "skyblue", color = "black") +
  labs(title = "Density Plot of Permutation Correlation Coefficients",
       x = "Correlation Coefficients",
       y = "Density")+
  geom_vline(xintercept = observed_cor, linetype = "dashed", color = "red", size = 1)
ggsave("../results/Florida.pdf", device = "pdf")


p_value <- sum(perm_cor >= observed_cor) / n_permutations

p_value

rm(list=ls())

load("../data/KeyWestAnnualMeanTemperature.RData")
ls()
class(ats)
head(ats)
plot(ats)

# Calculate the observed correlation coefficient
observed_cor <- cor(ats$Year, ats$Temp)
# Set the number of permutations
n_permutations <- 10000  # You can increase this for more accuracy
# Initialize a vector to store permutation correlation coefficients
perm_cor <- numeric(n_permutations)

# Perform the permutation test
for (i in 1:n_permutations) {
  # Shuffle the temperature data while keeping the years in the same order
  shuffled_temp <- sample(ats$Temp)
  
  # Calculate the correlation coefficient for the shuffled data
  perm_cor[i] <- cor(ats$Year, shuffled_temp)
}
# Assuming you've already conducted the permutation test and have the perm_cor vector

# Load necessary libraries
library(ggplot2)

# Create a density plot of permutation correlation coefficients
ggplot(data.frame(perm_cor = perm_cor), aes(x = perm_cor)) +
  geom_density(fill = "skyblue", color = "black") +
  labs(title = "Density Plot of Permutation Correlation Coefficients",
       x = "Correlation Coefficients",
       y = "Density")+
  geom_vline(xintercept = observed_cor, linetype = "dashed", color = "red", size = 1)
ggsave("../results/Florida.pdf", device = "pdf")

observed_cor

p_value <- sum(perm_cor >= observed_cor) / n_permutations

p_value
source("F.tex")
source("F.tex")
source("F.tex")
\documentclass[a4paper,12pt]{article}
\usepackage{graphicx}
\usepackage{listings}

\title{Is Florida getting warmer?}
\author{Zhongbin Hu}
\date{21/10/2023}

\begin{document}

  \maketitle

  \section{Results}
  \begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{../data/Florida.pdf}
    \caption{Distribution of Permutation Correlation Coefficients with Observed Coefficient}
    \label{Florida}
  \end{figure}

The figure above includes the permuted corrlation coefficients and observed coefficient.The observed correlation coefficient between years and temperature in the original dataset was calculated to be around 0.5331784. 
After 10,000 permutations and caculation, it was found that all of 10,000 permuted correlation coefficients were smaller or equal than the observed one. The approximate p-value is 0 after caculation.

\section{Interpretation}
From the figure the permuted correlation coefficients is nearly normaly distributed, and the observed coefficient is larger than all the permuted coefficient. This means the observed coefficient hardly occured by random chance.
In addition, the approximate samll p-value obtained from the permutation test suggests that the correlation between years and temperature is statistically significant.
Since the observed coefficient is larger than 0, there is a positive correlation between the year and temperature.
Therefore, the data supports the hypothesis that there is a significant correlation between the year and temperature Florida during the 20th century and Florida is becoming warmer.


\end{document}

 pdflatex F.tex
pdflatex F.tex
pdflatex F.tex
bibtex F
pdflatex F.tex
pdflatex F.tex
getwd()
